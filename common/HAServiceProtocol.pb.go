// Code generated by protoc-gen-go.
// source: gopkg.in/freddierice/go-hproto.v1/common/HAServiceProtocol.proto
// DO NOT EDIT!

package hproto_common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type HAServiceStateProto int32

const (
	HAServiceStateProto_INITIALIZING HAServiceStateProto = 0
	HAServiceStateProto_ACTIVE       HAServiceStateProto = 1
	HAServiceStateProto_STANDBY      HAServiceStateProto = 2
)

var HAServiceStateProto_name = map[int32]string{
	0: "INITIALIZING",
	1: "ACTIVE",
	2: "STANDBY",
}
var HAServiceStateProto_value = map[string]int32{
	"INITIALIZING": 0,
	"ACTIVE":       1,
	"STANDBY":      2,
}

func (x HAServiceStateProto) Enum() *HAServiceStateProto {
	p := new(HAServiceStateProto)
	*p = x
	return p
}
func (x HAServiceStateProto) String() string {
	return proto.EnumName(HAServiceStateProto_name, int32(x))
}
func (x *HAServiceStateProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HAServiceStateProto_value, data, "HAServiceStateProto")
	if err != nil {
		return err
	}
	*x = HAServiceStateProto(value)
	return nil
}
func (HAServiceStateProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type HARequestSource int32

const (
	HARequestSource_REQUEST_BY_USER        HARequestSource = 0
	HARequestSource_REQUEST_BY_USER_FORCED HARequestSource = 1
	HARequestSource_REQUEST_BY_ZKFC        HARequestSource = 2
)

var HARequestSource_name = map[int32]string{
	0: "REQUEST_BY_USER",
	1: "REQUEST_BY_USER_FORCED",
	2: "REQUEST_BY_ZKFC",
}
var HARequestSource_value = map[string]int32{
	"REQUEST_BY_USER":        0,
	"REQUEST_BY_USER_FORCED": 1,
	"REQUEST_BY_ZKFC":        2,
}

func (x HARequestSource) Enum() *HARequestSource {
	p := new(HARequestSource)
	*p = x
	return p
}
func (x HARequestSource) String() string {
	return proto.EnumName(HARequestSource_name, int32(x))
}
func (x *HARequestSource) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HARequestSource_value, data, "HARequestSource")
	if err != nil {
		return err
	}
	*x = HARequestSource(value)
	return nil
}
func (HARequestSource) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

type HAStateChangeRequestInfoProto struct {
	ReqSource        *HARequestSource `protobuf:"varint,1,req,name=reqSource,enum=hproto.common.HARequestSource" json:"reqSource,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *HAStateChangeRequestInfoProto) Reset()                    { *m = HAStateChangeRequestInfoProto{} }
func (m *HAStateChangeRequestInfoProto) String() string            { return proto.CompactTextString(m) }
func (*HAStateChangeRequestInfoProto) ProtoMessage()               {}
func (*HAStateChangeRequestInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *HAStateChangeRequestInfoProto) GetReqSource() HARequestSource {
	if m != nil && m.ReqSource != nil {
		return *m.ReqSource
	}
	return HARequestSource_REQUEST_BY_USER
}

// *
// void request
type MonitorHealthRequestProto struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *MonitorHealthRequestProto) Reset()                    { *m = MonitorHealthRequestProto{} }
func (m *MonitorHealthRequestProto) String() string            { return proto.CompactTextString(m) }
func (*MonitorHealthRequestProto) ProtoMessage()               {}
func (*MonitorHealthRequestProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

// *
// void response
type MonitorHealthResponseProto struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *MonitorHealthResponseProto) Reset()                    { *m = MonitorHealthResponseProto{} }
func (m *MonitorHealthResponseProto) String() string            { return proto.CompactTextString(m) }
func (*MonitorHealthResponseProto) ProtoMessage()               {}
func (*MonitorHealthResponseProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

// *
// void request
type TransitionToActiveRequestProto struct {
	ReqInfo          *HAStateChangeRequestInfoProto `protobuf:"bytes,1,req,name=reqInfo" json:"reqInfo,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *TransitionToActiveRequestProto) Reset()                    { *m = TransitionToActiveRequestProto{} }
func (m *TransitionToActiveRequestProto) String() string            { return proto.CompactTextString(m) }
func (*TransitionToActiveRequestProto) ProtoMessage()               {}
func (*TransitionToActiveRequestProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *TransitionToActiveRequestProto) GetReqInfo() *HAStateChangeRequestInfoProto {
	if m != nil {
		return m.ReqInfo
	}
	return nil
}

// *
// void response
type TransitionToActiveResponseProto struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *TransitionToActiveResponseProto) Reset()                    { *m = TransitionToActiveResponseProto{} }
func (m *TransitionToActiveResponseProto) String() string            { return proto.CompactTextString(m) }
func (*TransitionToActiveResponseProto) ProtoMessage()               {}
func (*TransitionToActiveResponseProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

// *
// void request
type TransitionToStandbyRequestProto struct {
	ReqInfo          *HAStateChangeRequestInfoProto `protobuf:"bytes,1,req,name=reqInfo" json:"reqInfo,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *TransitionToStandbyRequestProto) Reset()                    { *m = TransitionToStandbyRequestProto{} }
func (m *TransitionToStandbyRequestProto) String() string            { return proto.CompactTextString(m) }
func (*TransitionToStandbyRequestProto) ProtoMessage()               {}
func (*TransitionToStandbyRequestProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *TransitionToStandbyRequestProto) GetReqInfo() *HAStateChangeRequestInfoProto {
	if m != nil {
		return m.ReqInfo
	}
	return nil
}

// *
// void response
type TransitionToStandbyResponseProto struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *TransitionToStandbyResponseProto) Reset()         { *m = TransitionToStandbyResponseProto{} }
func (m *TransitionToStandbyResponseProto) String() string { return proto.CompactTextString(m) }
func (*TransitionToStandbyResponseProto) ProtoMessage()    {}
func (*TransitionToStandbyResponseProto) Descriptor() ([]byte, []int) {
	return fileDescriptor2, []int{6}
}

// *
// void request
type GetServiceStatusRequestProto struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *GetServiceStatusRequestProto) Reset()                    { *m = GetServiceStatusRequestProto{} }
func (m *GetServiceStatusRequestProto) String() string            { return proto.CompactTextString(m) }
func (*GetServiceStatusRequestProto) ProtoMessage()               {}
func (*GetServiceStatusRequestProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

// *
// Returns the state of the service
type GetServiceStatusResponseProto struct {
	State *HAServiceStateProto `protobuf:"varint,1,req,name=state,enum=hproto.common.HAServiceStateProto" json:"state,omitempty"`
	// If state is STANDBY, indicate whether it is
	// ready to become active.
	ReadyToBecomeActive *bool `protobuf:"varint,2,opt,name=readyToBecomeActive" json:"readyToBecomeActive,omitempty"`
	// If not ready to become active, a textual explanation of why not
	NotReadyReason   *string `protobuf:"bytes,3,opt,name=notReadyReason" json:"notReadyReason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GetServiceStatusResponseProto) Reset()                    { *m = GetServiceStatusResponseProto{} }
func (m *GetServiceStatusResponseProto) String() string            { return proto.CompactTextString(m) }
func (*GetServiceStatusResponseProto) ProtoMessage()               {}
func (*GetServiceStatusResponseProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *GetServiceStatusResponseProto) GetState() HAServiceStateProto {
	if m != nil && m.State != nil {
		return *m.State
	}
	return HAServiceStateProto_INITIALIZING
}

func (m *GetServiceStatusResponseProto) GetReadyToBecomeActive() bool {
	if m != nil && m.ReadyToBecomeActive != nil {
		return *m.ReadyToBecomeActive
	}
	return false
}

func (m *GetServiceStatusResponseProto) GetNotReadyReason() string {
	if m != nil && m.NotReadyReason != nil {
		return *m.NotReadyReason
	}
	return ""
}

func init() {
	proto.RegisterType((*HAStateChangeRequestInfoProto)(nil), "hproto.common.HAStateChangeRequestInfoProto")
	proto.RegisterType((*MonitorHealthRequestProto)(nil), "hproto.common.MonitorHealthRequestProto")
	proto.RegisterType((*MonitorHealthResponseProto)(nil), "hproto.common.MonitorHealthResponseProto")
	proto.RegisterType((*TransitionToActiveRequestProto)(nil), "hproto.common.TransitionToActiveRequestProto")
	proto.RegisterType((*TransitionToActiveResponseProto)(nil), "hproto.common.TransitionToActiveResponseProto")
	proto.RegisterType((*TransitionToStandbyRequestProto)(nil), "hproto.common.TransitionToStandbyRequestProto")
	proto.RegisterType((*TransitionToStandbyResponseProto)(nil), "hproto.common.TransitionToStandbyResponseProto")
	proto.RegisterType((*GetServiceStatusRequestProto)(nil), "hproto.common.GetServiceStatusRequestProto")
	proto.RegisterType((*GetServiceStatusResponseProto)(nil), "hproto.common.GetServiceStatusResponseProto")
	proto.RegisterEnum("hproto.common.HAServiceStateProto", HAServiceStateProto_name, HAServiceStateProto_value)
	proto.RegisterEnum("hproto.common.HARequestSource", HARequestSource_name, HARequestSource_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for HAServiceProtocolService service

type HAServiceProtocolServiceClient interface {
	// *
	// Monitor the health of a service.
	MonitorHealth(ctx context.Context, in *MonitorHealthRequestProto, opts ...grpc.CallOption) (*MonitorHealthResponseProto, error)
	// *
	// Request service to tranisition to active state.
	TransitionToActive(ctx context.Context, in *TransitionToActiveRequestProto, opts ...grpc.CallOption) (*TransitionToActiveResponseProto, error)
	// *
	// Request service to transition to standby state.
	TransitionToStandby(ctx context.Context, in *TransitionToStandbyRequestProto, opts ...grpc.CallOption) (*TransitionToStandbyResponseProto, error)
	// *
	// Get the current status of the service.
	GetServiceStatus(ctx context.Context, in *GetServiceStatusRequestProto, opts ...grpc.CallOption) (*GetServiceStatusResponseProto, error)
}

type hAServiceProtocolServiceClient struct {
	cc *grpc.ClientConn
}

func NewHAServiceProtocolServiceClient(cc *grpc.ClientConn) HAServiceProtocolServiceClient {
	return &hAServiceProtocolServiceClient{cc}
}

func (c *hAServiceProtocolServiceClient) MonitorHealth(ctx context.Context, in *MonitorHealthRequestProto, opts ...grpc.CallOption) (*MonitorHealthResponseProto, error) {
	out := new(MonitorHealthResponseProto)
	err := grpc.Invoke(ctx, "/hproto.common.HAServiceProtocolService/monitorHealth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hAServiceProtocolServiceClient) TransitionToActive(ctx context.Context, in *TransitionToActiveRequestProto, opts ...grpc.CallOption) (*TransitionToActiveResponseProto, error) {
	out := new(TransitionToActiveResponseProto)
	err := grpc.Invoke(ctx, "/hproto.common.HAServiceProtocolService/transitionToActive", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hAServiceProtocolServiceClient) TransitionToStandby(ctx context.Context, in *TransitionToStandbyRequestProto, opts ...grpc.CallOption) (*TransitionToStandbyResponseProto, error) {
	out := new(TransitionToStandbyResponseProto)
	err := grpc.Invoke(ctx, "/hproto.common.HAServiceProtocolService/transitionToStandby", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hAServiceProtocolServiceClient) GetServiceStatus(ctx context.Context, in *GetServiceStatusRequestProto, opts ...grpc.CallOption) (*GetServiceStatusResponseProto, error) {
	out := new(GetServiceStatusResponseProto)
	err := grpc.Invoke(ctx, "/hproto.common.HAServiceProtocolService/getServiceStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for HAServiceProtocolService service

type HAServiceProtocolServiceServer interface {
	// *
	// Monitor the health of a service.
	MonitorHealth(context.Context, *MonitorHealthRequestProto) (*MonitorHealthResponseProto, error)
	// *
	// Request service to tranisition to active state.
	TransitionToActive(context.Context, *TransitionToActiveRequestProto) (*TransitionToActiveResponseProto, error)
	// *
	// Request service to transition to standby state.
	TransitionToStandby(context.Context, *TransitionToStandbyRequestProto) (*TransitionToStandbyResponseProto, error)
	// *
	// Get the current status of the service.
	GetServiceStatus(context.Context, *GetServiceStatusRequestProto) (*GetServiceStatusResponseProto, error)
}

func RegisterHAServiceProtocolServiceServer(s *grpc.Server, srv HAServiceProtocolServiceServer) {
	s.RegisterService(&_HAServiceProtocolService_serviceDesc, srv)
}

func _HAServiceProtocolService_MonitorHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MonitorHealthRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HAServiceProtocolServiceServer).MonitorHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hproto.common.HAServiceProtocolService/MonitorHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HAServiceProtocolServiceServer).MonitorHealth(ctx, req.(*MonitorHealthRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _HAServiceProtocolService_TransitionToActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransitionToActiveRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HAServiceProtocolServiceServer).TransitionToActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hproto.common.HAServiceProtocolService/TransitionToActive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HAServiceProtocolServiceServer).TransitionToActive(ctx, req.(*TransitionToActiveRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _HAServiceProtocolService_TransitionToStandby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransitionToStandbyRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HAServiceProtocolServiceServer).TransitionToStandby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hproto.common.HAServiceProtocolService/TransitionToStandby",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HAServiceProtocolServiceServer).TransitionToStandby(ctx, req.(*TransitionToStandbyRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

func _HAServiceProtocolService_GetServiceStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceStatusRequestProto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HAServiceProtocolServiceServer).GetServiceStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hproto.common.HAServiceProtocolService/GetServiceStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HAServiceProtocolServiceServer).GetServiceStatus(ctx, req.(*GetServiceStatusRequestProto))
	}
	return interceptor(ctx, in, info, handler)
}

var _HAServiceProtocolService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hproto.common.HAServiceProtocolService",
	HandlerType: (*HAServiceProtocolServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "monitorHealth",
			Handler:    _HAServiceProtocolService_MonitorHealth_Handler,
		},
		{
			MethodName: "transitionToActive",
			Handler:    _HAServiceProtocolService_TransitionToActive_Handler,
		},
		{
			MethodName: "transitionToStandby",
			Handler:    _HAServiceProtocolService_TransitionToStandby_Handler,
		},
		{
			MethodName: "getServiceStatus",
			Handler:    _HAServiceProtocolService_GetServiceStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor2,
}

func init() {
	proto.RegisterFile("gopkg.in/freddierice/go-hproto.v1/common/HAServiceProtocol.proto", fileDescriptor2)
}

var fileDescriptor2 = []byte{
	// 554 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x54, 0xef, 0x6e, 0xd2, 0x50,
	0x14, 0xb7, 0x2c, 0x3a, 0x77, 0xe6, 0xb6, 0xe6, 0x92, 0x28, 0xd6, 0x0d, 0xb1, 0x1f, 0x0c, 0xce,
	0xad, 0x28, 0x9f, 0x4c, 0xf4, 0xc3, 0x0a, 0x83, 0xd1, 0xa8, 0xa8, 0xa5, 0xd3, 0x6c, 0x89, 0x21,
	0xb5, 0xbd, 0x6b, 0x1b, 0xc7, 0x3d, 0xac, 0xbd, 0x90, 0xec, 0x0d, 0x7c, 0x0c, 0xdf, 0xc1, 0xd7,
	0xf1, 0x61, 0xbc, 0xd0, 0x9a, 0x95, 0x16, 0xeb, 0xbe, 0xec, 0x0b, 0x37, 0xdc, 0xf3, 0xfb, 0xc7,
	0x3d, 0xe7, 0x00, 0x07, 0x1e, 0x8e, 0xbf, 0x7b, 0x5a, 0xc0, 0x1a, 0x67, 0x21, 0x75, 0xdd, 0x80,
	0x86, 0x81, 0x43, 0x1b, 0x1e, 0xee, 0xfb, 0xe3, 0x10, 0x39, 0x6a, 0xd3, 0x97, 0x0d, 0x07, 0x47,
	0x23, 0x64, 0x8d, 0x9e, 0x3e, 0xa0, 0xe1, 0x54, 0x54, 0x3f, 0xce, 0x0a, 0x0e, 0x9e, 0x6b, 0x73,
	0x04, 0xd9, 0x48, 0x90, 0x31, 0x4c, 0xfd, 0x0a, 0x3b, 0x02, 0xc9, 0x6d, 0x4e, 0xdb, 0xbe, 0xcd,
	0x3c, 0x6a, 0xd2, 0x8b, 0x09, 0x8d, 0xb8, 0xc1, 0xce, 0x70, 0x4e, 0x24, 0x6f, 0x60, 0x2d, 0xa4,
	0x17, 0x03, 0x9c, 0x84, 0x0e, 0xad, 0x48, 0xb5, 0x52, 0x7d, 0xb3, 0x59, 0xd5, 0x16, 0x34, 0xb4,
	0x9e, 0x9e, 0xb0, 0x62, 0x94, 0x79, 0x45, 0x50, 0x1f, 0xc1, 0xc3, 0xf7, 0xc8, 0x02, 0x8e, 0x61,
	0x8f, 0xda, 0xe7, 0xdc, 0x4f, 0x80, 0x73, 0x69, 0x75, 0x1b, 0x94, 0x4c, 0x31, 0x1a, 0x23, 0x8b,
	0xe2, 0xc4, 0xaa, 0x0f, 0x55, 0x2b, 0xb4, 0x59, 0x14, 0xf0, 0x00, 0x99, 0x85, 0xba, 0xc3, 0x83,
	0x29, 0x4d, 0xf3, 0x49, 0x17, 0x56, 0x85, 0xd3, 0x2c, 0xea, 0x3c, 0xd8, 0x7a, 0x73, 0x2f, 0x17,
	0xac, 0xe0, 0x97, 0x99, 0x7f, 0xc9, 0xea, 0x13, 0x78, 0xbc, 0xcc, 0x29, 0x1d, 0x26, 0x58, 0x84,
	0x08, 0x59, 0xe6, 0x7e, 0xbb, 0xbc, 0x91, 0x34, 0x2a, 0xd4, 0x96, 0x5a, 0xa5, 0xe3, 0x54, 0x61,
	0xfb, 0x88, 0xf2, 0xa4, 0xc1, 0x33, 0xd5, 0x49, 0xb4, 0xf0, 0xb2, 0xbf, 0x24, 0xd8, 0xc9, 0x03,
	0x52, 0x0a, 0xe4, 0x15, 0xdc, 0x8e, 0x66, 0x69, 0x92, 0x96, 0xaa, 0xf9, 0xac, 0x57, 0xdc, 0x98,
	0x62, 0xc6, 0x04, 0xf2, 0x02, 0xca, 0x21, 0xb5, 0xdd, 0x4b, 0x0b, 0x5b, 0x54, 0xa0, 0x69, 0xfc,
	0x5c, 0x95, 0x52, 0x4d, 0xaa, 0xdf, 0x35, 0x97, 0x95, 0xc8, 0x53, 0xd8, 0x64, 0xc8, 0xcd, 0x59,
	0x45, 0x7c, 0x44, 0xc8, 0x2a, 0x2b, 0x02, 0xbc, 0x66, 0x66, 0x6e, 0x77, 0x0f, 0xa0, 0xbc, 0xc4,
	0x97, 0xc8, 0x70, 0xcf, 0xe8, 0x1b, 0x96, 0xa1, 0xbf, 0x33, 0x4e, 0x8d, 0xfe, 0x91, 0x7c, 0x8b,
	0x00, 0xdc, 0xd1, 0xdb, 0x96, 0xf1, 0xb9, 0x23, 0x4b, 0x64, 0x1d, 0x56, 0x07, 0x96, 0xde, 0x3f,
	0x6c, 0x9d, 0xc8, 0xa5, 0xdd, 0x2f, 0xb0, 0x95, 0x19, 0x46, 0x52, 0x86, 0x2d, 0xb3, 0xf3, 0xe9,
	0xb8, 0x33, 0xb0, 0x86, 0xad, 0x93, 0xe1, 0xf1, 0xa0, 0x63, 0x0a, 0x01, 0x05, 0xee, 0x67, 0x2e,
	0x87, 0xdd, 0x0f, 0x66, 0xbb, 0x73, 0x28, 0x04, 0x17, 0x09, 0xa7, 0x6f, 0xbb, 0x6d, 0xb9, 0xd4,
	0xfc, 0xbd, 0x02, 0x95, 0xdc, 0x46, 0x25, 0x5f, 0x89, 0x0b, 0x1b, 0xa3, 0xf4, 0x1c, 0x93, 0x7a,
	0xe6, 0x35, 0xff, 0xb9, 0x02, 0xca, 0xb3, 0x62, 0x64, 0xba, 0x63, 0x11, 0x10, 0x9e, 0x9b, 0x52,
	0xb2, 0x9f, 0x11, 0x28, 0x5e, 0x19, 0x45, 0xbb, 0x06, 0x3c, 0x6d, 0x3a, 0x85, 0x32, 0xcf, 0x0f,
	0x23, 0x29, 0x92, 0x59, 0xb2, 0x1b, 0x4a, 0xe3, 0x3a, 0xf8, 0xb4, 0xef, 0x08, 0x64, 0x2f, 0x33,
	0xbf, 0xe4, 0x79, 0x46, 0xa4, 0x68, 0x03, 0x94, 0xbd, 0xff, 0x82, 0x53, 0x76, 0xad, 0xd7, 0xa0,
	0x60, 0xe8, 0x69, 0xf6, 0xd8, 0x76, 0x7c, 0xaa, 0xf9, 0xb6, 0x8b, 0x38, 0x16, 0x47, 0xfc, 0x97,
	0xd9, 0x7a, 0x90, 0xeb, 0xfc, 0xfc, 0x8c, 0x7e, 0x48, 0xd2, 0x4f, 0x49, 0xfa, 0x13, 0x00, 0x00,
	0xff, 0xff, 0x97, 0xff, 0x6c, 0x2a, 0x94, 0x05, 0x00, 0x00,
}
